# Process to create a system call

### Run on the system

The system call is created on the [xv6](https://github.com/mit-pdos/xv6-public) operating system. To start up the system on virtual machine, in the xv6 folder directory, type command

```bash
make qemu-nox
```

To quit the system, press `ctrl A + x`.



### System call mechanism

#### user/

The complete process of a system call  starts from the user mode. In the user folder defined functions that users can call freely. To invoke a system call, one need to include the header `user.h`, which claims to contain all the declarations of the "system calls".  Selected delcarations in `user.h` are as follow.

```C
#ifndef _USER_H_
#define _USER_H_

struct stat;

// system calls
int fork(void);
int exit(void) __attribute__((noreturn));
int wait(void);
int close(int);
int open(char*, int);
...

// user library functions (ulib.c)
char* strcpy(char*, char*);
void printf(int, char*, ...);
void* malloc(uint);
void free(void*);
...
    
#endif // _USER_H_
```

In fact, there is no `user.c` which defines the claimed system calls. All the system calls in `user.h` are actually specified with instructions in the assembly file `usys.S`. 

```assembly
#include "syscall.h"
#include "traps.h"

#define SYSCALL(name) \
  .globl name; \
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
SYSCALL(exit)
...
```

the macro in `sys.S` actually moves a number `$SYS_name` into the register `%eax`. Then it calls the `int` instruction (short for interruption) and jumps into the system call trap. After finished, it then returns.

#### include/

The process then moves to the kernel mode. First notice several important header files in the directory include/. The first one to look is `syscall.h`, where we could find a sequence of macro definition. This file defines the number corresponds to each function call in `usys.S` , which will then be stored in the register `%eax`.

```C
#ifndef _SYSCALL_H_
#define _SYSCALL_H_

// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
...
#define SYS_sleep  20
#define SYS_uptime 21
    
#endif // _SYSCALL_H_

```

Next to look at `traps.h`. This header defines all the numbers correspond to each type of trap. So that when an interruption is raised, the system could know which trap it is dealing with. For example, the number corresponds to the trap of system call is 64.

```C
#ifndef _TRAPS_H_
#define _TRAPS_H_

// x86 trap and interrupt constants.
...
#define T_SYSCALL       64      // system call
...

#endif // _TRAPS_H_

```

#### kernel/

The rest and major part lies in kernel/. There are a bunch of important files in this directory. `bootasm.S` is the first file executed when booting. To inform the cpu of information it needs durig operating (such as traps, system calls), relevant information needs to be initialized at booting. First to notice the file `main.c`. Inside there is a function `mainc`.

```C
// Set up hardware and software.
// Runs only on the boostrap processor.
void
mainc(void)
{
  cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
  ...
  tvinit();        // trap vectors
  ...
}
```

Inside there is an important line, which set up the trap vectors. This function is defined in `trap.c`:

```C
void
tvinit(void)
{
  int i;

  for(i = 0; i < 256; i++)
    SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
  SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
  
  initlock(&tickslock, "time");
}
```

At this time, the initialization is set up in memory, but the cpu still don't know where they are. More closely, the for loop in `tvinit` deals with the `vectors` data structure, which is specified in`vector.S`. This file specifies the instructions for all 256 vectors.

```assembly
# generated by vectors.pl - do not edit
# handlers
.globl alltraps
...
.globl vector64
vector64:
  pushl $0
  pushl $64
  jmp alltraps
...

# vector table
.data
.globl vectors
vectors:
  .long vector0
  ...
  .long vector64
  ...
```

Every instruction is about push some values on stack, and jump to `alltraps`. This instruction is defined in `trapasm.S` as follow:

```assembly
.globl alltraps
alltraps:
  # Build trap frame.
  pushl %ds
  pushl %es
  pushl %fs
  pushl %gs
  pushal
  
  ...

  # Call trap(tf), where tf=%esp
  pushl %esp
  call trap
  addl $4, %esp

```

It starts with pushing some register values on stack (for saving purpose), which is the kernel stck for each process when it is created. And at the end, it calls function `trap`, which is also defined in `trap.c`. We are ony interested in the first part which deals with system call:

```C
void
trap(struct trapframe *tf)
{
  if(tf->trapno == T_SYSCALL){
    if(proc->killed)
      exit();
    proc->tf = tf;
    syscall();
    if(proc->killed)
      exit();
    return;
  }

```

if the call is valid, the structure `proc->tf` will take the address in `%esp` and then call `syscall()` in `syscall.c`:

```C
// array of function pointers to handlers for all the syscalls
static int (*syscalls[])(void) = {
[SYS_chdir]   sys_chdir,
...
[SYS_uptime]  sys_uptime,
};

// Called on a syscall trap. Checks that the syscall number (passed via eax)
// is valid and then calls the appropriate handler for the syscall.
void
syscall(void)
{
  int num;wh
  
  num = proc->tf->eax;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num] != NULL) {
    proc->tf->eax = syscalls[num]();
  } else {
    cprintf("%d %s: unknown sys call %d\n",
            proc->pid, proc->name, num);
    proc->tf->eax = -1;
  }
}


```

Finally, at this time, by looking at `proc->tf->eax`, the cpu knows which system call it is callingm and using the function pointer to call it.

### Adding a new system call

All system calls ar declared in `sysfunct.h`, and defined in `sysfile.c` or `sysproc.c`. To add a system call, first define it in `sysproc.c`, and declare it in `sysfunct.h`. Then also update `include/syscall.h`, and add the corresponding version (without SYS_ as prefix) in `user/usys.S` and `user/user.h` to make it visible to users.





